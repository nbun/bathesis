\documentclass{beamer}
\usepackage{ulem}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{subcaption}
\usepackage{graphicx}
\usemintedstyle[haskell]{trac}
\newminted{haskell}{fontsize=\small}
\newminted{coq}{fontsize=\small}
\newcommand{\coqinline}[1]{\mintinline{coq}{#1}}

\mode<presentation>
{
  %\usetheme{Antibes}
  %\usecolortheme{lily}
  \usetheme{metropolis}
}


\usepackage[german]{babel}
% or whatever

\usepackage[utf8]{inputenc}
% or whatever

%\usepackage{times}
\usepackage[T1]{fontenc}
\setbeamersize{text margin left=1.5em,text margin right=1.5em}

\title{Formalisierung von Inferenzsystemen in Coq am Beispiel von Typsystemen für Curry}

%\subtitle{Bachelor's Thesis} % (optional)

\author{Niels Bunkenburg}

\institute{ 
	Arbeitsgruppe für Programmiersprachen und Übersetzerkonstruktion \par
	Institut für Informatik \par
	Christian-Albrechts-Universität zu Kiel}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[Short Occasion] % (optional)
{29.09.2016}

\subject{Formalisierung von Inferenzsystemen in Coq am Beispiel von Typsystemen für Curry}

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Motivation}
\hfill
\begin{minipage}[t]{.45 \linewidth}
	\centering
	\includegraphics[scale=.5]{images/curry_2.png}\\
	Curry
\end{minipage}
\hfill
\begin{minipage}[t]{.4 \linewidth}
	\centering
	\includegraphics[scale=.8]{images/coq_logo.png}\\
	Coq
\end{minipage}
\hfill
\end{frame}

\begin{frame}[fragile]{Curry}
\begin{itemize}
\item Syntax ähnlich zu Haskell
\item Nichtdeterminismus
\begin{haskellcode}
  (?)   :: a -> a -> a
  x ? _ = x
  _ ? y = y
\end{haskellcode}
\item Freie Variablen
\begin{coqcode}
> 1 + 1 == x where x free
  {x = (-_x2)} False
  {x = 0} False
  {x = 1} False
  {x = 2} True
  {x = (2 * _x3 + 1)} False
  {x = (4 * _x4)} False
  {x = (4 * _x4 + 2)} False		
\end{coqcode}
\end{itemize}
\end{frame}
\begin{frame}[fragile]{Coq - Aussagen}
\begin{itemize}
\item Aussagen in Coq: \coqinline{Prop}
\begin{coqcode}
  1 + 1 = 2
  False -> False
  forall (X : Type) (l : list X), [] ++ l = l
  fun (x : nat) => x <> 2
\end{coqcode}
\vspace*{.5em}
\item Induktiv definierte Aussagen
\begin{coqcode}
  Inductive inInd {X : Type} : X -> list X -> Prop :=
    | head : forall n l, inInd n (n :: l)
    | tail : forall n l e, inInd n l -> inInd n (e :: l).

  Example e : inInd 2 [1;2;4].
  Proof.
    apply tail. (* inInd 2 [2; 4] *)
    apply head.
  Qed.
\end{coqcode}
\end{itemize}
\end{frame}
\begin{frame}{Was ist Typisierung?}
\begin{itemize}
	\item \textbf{Typ}: Menge von Werten, die Eigenschaften und Bedeutung der Elemente bestimmt.
	\item \textbf{Ausdruck}: Kombination von Literalen, Variablen, Operatoren und Funktionen.
	\item \textbf{Kontext}: Enthält Informationen über Variablen und das Programm.
	\item \textbf{Typisierung}: In einem Kontext $\Gamma$ wird einem Ausdruck $e$ ein Typ $\tau$ zugewiesen, notiert als $\Gamma \vdash e :: \tau$.
\end{itemize}
Beispiele:
\begin{itemize}
	\item $\Gamma \vdash 2 :: \texttt{Int}$
	\item $\Gamma, x \mapsto \texttt{Int}  \vdash \texttt{x + 2} :: \texttt{Int}$
\end{itemize}
%todo beispiel
\end{frame}
\begin{frame}[fragile]{Inferenzsysteme}
\begin{itemize}
\item Inferenzsystem: Menge von Inferenzregeln
\item Inferenzregel: \infer{c}{p_1 \dots p_n} wo $p_i$ Prämissen und $c$ Konklusion
\item Notation für Implikation $p_1 \rightarrow \dots \rightarrow p_n \rightarrow c$
\item Darstellung von Inferenzregeln in Coq:
\vfill
	\begin{minipage}{.45 \linewidth}
		\infer[\text{\texttt{head}}]{\coqinline{In x (x :: l)}}{\phantom{premise}}
	\end{minipage}
	\hspace{.1 \linewidth}
	\begin{minipage}{.45 \linewidth}
		\infer[\text{\texttt{tail}}]{\coqinline{In x (y :: l)}}{\coqinline{In x l}}
	\end{minipage}
\vfill
\begin{coqcode}
Inductive inInd {X : Type} : X -> list X -> Prop :=
  | head : forall x l, inInd x (x :: l)
  | tail : forall x y l, inInd x l -> inInd x (y :: l).
\end{coqcode}
\end{itemize}
\end{frame}
\begin{frame}{Formalisierung von Curry}
Vorgehensweise:
\begin{enumerate}
	\item Syntax und Kontext in Coq darstellen.
	\item Typisierungsregeln in induktive Aussagen umwandeln.
	\item Code umwandeln und Eigenschaften beweisen.
\end{enumerate}
Sprachen:
\begin{itemize}
	\item CuMin (Curry Minor): Vereinfachte Teilsprache von Curry.
	\item FlatCurry: Zwischensprache, die in Curry Compilern benutzt wird.
\end{itemize}
\end{frame}
\begin{frame}{CuMin -- Syntax in BNF}
Syntax von CuMin in Backus-Naur-Form:
\begin{align*}
P &::= D;P \:|\:D \\
D &::= f :: \kappa \tau; f \overline{x_{n}} = e\\
\kappa &::= \forall^{\epsilon} \alpha.\kappa \:|\: \forall^{*}\alpha.\kappa \:|\: \epsilon \\
\tau &::= \alpha \:|\: \text{Bool} \:|\: \text{Nat} \:|\: [\tau] \:|\: (\tau,\tau ') \:|\: \tau \rightarrow \tau ' \\
e &::= x \:|\: f_{\overline{\tau_{m}}} \:|\: e_{1}\: e_{2} \:|\: \text{let}\: x = e_{1} \:\text{in}\: e_{2} \:|\: n \:|\: e_{1} + e_{2} \:|\: e_{1} \circeq e_{2}\\
&\:|\: (e_{1},e_{2}) \:|\: \text{case}\: e \:\text{of}\: \langle (x,y) \rightarrow e_{1}\rangle\\
&\:|\: \text{True} \:|\: \text{False} \:|\: \text{case}\: e \:\text{of}\: \langle \text{True} \rightarrow e_{1};\:\text{False} \rightarrow e_{2}\rangle\\
&\:|\: \text{Nil}_{\tau} \:|\: \text{Cons}(e_{1}, e_{2}) \:|\: \text{case}\: e \:\text{of}\: \langle \text{Nil} \rightarrow e_{1};\:\text{Cons}(x,y) \rightarrow e_{2}\rangle\\
&\:|\: \text{failure}_{\tau} \:|\: \text{anything}_{\tau}
\end{align*}
\end{frame}

\begin{frame}[fragile]{CuMin -- Syntax in Coq}
Darstellung der Syntax von CuMin in Coq:
\begin{coqcode}	
Inductive ty : Type :=
  | TVar  : id -> ty
  | TBool : ty
  | TNat  : ty
  | TList : ty -> ty
  | TPair : ty -> ty -> ty
  | TFun  : ty -> ty -> ty.

Inductive func_decl : Type :=
  | FDecl : id -> list quantifier -> ty ->
            list id -> tm -> func_decl.
\end{coqcode}
\end{frame}

\begin{frame}[fragile]{Beispiel CuMin}
	Formale Definition:\\
	\begin{minipage}{.45 \linewidth}
		\begin{align*}
		&\text{fst}::\forall^{*}\alpha.\forall^{*}\beta.(\alpha, \beta) \rightarrow\alpha\\
		&\text{fst}\: p = \text{case}\: p\: \text{of}\: \langle(u,v) \rightarrow u\rangle
		\end{align*}
	\end{minipage}
	\begin{minipage}{.45 \linewidth}
		\begin{align*}
		&\text{one} :: \text{Nat}\\
		&\text{one} = \text{fst}_{Nat, Bool} ~ (1, \text{True})
		\end{align*}
	\end{minipage}
	\vspace*{1em}
	
	Coq Definition:
	\begin{coqcode}
  Definition fst := FDecl (Id 0)
    [for_all (Id 1) tag_star; for_all (Id 2) tag_star] 
    (TFun (TPair (TVar (Id 1)) (TVar (Id 2))) (TVar (Id 1)))
    [Id 3]
    (tcasep (tvar (Id 3)) (Id 4) (Id 5) (tvar (Id 4))).
		
  Definition one := tapp (tfun (Id 0) [TNat; TBool])
    (tpair (tsucc tzero) ttrue).
	\end{coqcode}
\end{frame}

\begin{frame}[fragile]{CuMin -- Datentypen und Kontext}
Inferenzregeln für Datentypen:
\begin{figure}[H]
	\begin{center}
		\begin{subfigure}{.3 \linewidth}
			\centering
			$\Gamma, \alpha^{*} \vdash \alpha \in$ Data
		\end{subfigure}
		\hfill
		\begin{subfigure}{.3 \linewidth}
			\centering
			$\Gamma \vdash$ Bool $\in$ Data
		\end{subfigure}
		\hfill
		\begin{subfigure}{.3 \linewidth}
			\centering
			$\Gamma \vdash$ Nat $\in$ Data
		\end{subfigure}\\
		\vspace{1em}
		\begin{subfigure}{.375 \linewidth}
			\centering
			\infer{\Gamma \vdash [\tau] \in \text{Data}}
			{\Gamma \vdash \tau \in \text{Data}}
		\end{subfigure}
		\hspace{.1 \linewidth}
		\begin{subfigure}{.375 \linewidth}
			\centering
			\infer{\Gamma \vdash (\tau,\tau') \in \text{Data}}
			{\Gamma \vdash \tau \in \text{Data} & \Gamma \vdash \tau' \in \text{Data}}
		\end{subfigure}
	\end{center}
\end{figure}
Informationen, die im Kontext enthalten sind:
\begin{coqcode}
  Definition program := list func_decl.

  Inductive context : Type := 
    | con: (partial_map id tag) -> (partial_map id ty) ->
            context.
\end{coqcode}
\end{frame}
\begin{frame}{CuMin -- formales Typsystem}
\begin{figure}[H]
	\begin{normalsize}
		\begin{center}
			\begin{subfigure}[t]{.25 \textwidth}
				\centering
				$\Gamma, \: x \mapsto \tau \vdash x :: \tau$
			\end{subfigure}
			\hspace*{1em}
			\begin{subfigure}[t]{.25 \textwidth}
				\centering
				$\Gamma \vdash \text{True} :: \text{Bool}$
			\end{subfigure}\\
			
			%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			\vspace*{2em}
				\begin{subfigure}[t]{.3 \linewidth}
					\centering
					\infer{\Gamma \vdash e_{1} ~ e_{2} :: \tau_{2} \phantom{\overline{]}}}
					{\Gamma \vdash e_{1} :: \tau_{1} \rightarrow \tau_{2} & \Gamma \vdash e_{2} :: \tau_{1}}
				\end{subfigure}\\
				%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				\vspace{2em}
				\hspace{.02 \linewidth}
				\begin{subfigure}[t]{.5 \linewidth}
					\centering
					\infer{\Gamma \vdash \text{case} \: e \: \text{of} \: \langle (l,r) \rightarrow e_{1} \rangle :: \tau}
					{\Gamma \vdash e :: (\tau_{1}, \tau_{2}) & \Gamma, l \mapsto \tau_{1}, r \mapsto \tau_{2} \vdash e_{1} :: \tau}
				\end{subfigure}\\
				%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				\vspace*{2em}
				\hspace{.02 \linewidth}
				\begin{subfigure}[t]{.3 \linewidth}
					\centering
					\infer[\bigstar]{\Gamma \vdash f_{\overline{\tau_{m}}} :: \tau      [\overline{\tau_{m}/\alpha_{m}}]}
					{(f :: \forall^{v_{1}} \alpha_{1}.\dotsb \forall^{v_{m}}\alpha_{m}.\tau; f \overline{x_{n}} = e) \in P}
				\end{subfigure}
				\vspace*{1em}
				\begin{flushright}
					$\bigstar$ Falls für alle $i$ mit $v_{i} = *$ gilt $\Gamma \vdash \tau_{i} \in \text{Data}.$
				\end{flushright}
				\end{center}
			\end{normalsize}
\end{figure}
\end{frame}

\begin{frame}[fragile]{CuMin -- Typsystem in Coq}
\begin{coqcode}
Reserved Notation "Gamma '|-' t ':::' T" (at level 40).
Inductive has_type : context -> tm -> ty -> Prop :=
  | T_Var   : forall Gamma x T,
               (type_con Gamma) x = Some T ->
               Gamma |- tvar x ::: T
  | T_App   : forall Gamma e1 e2 T1 T2,
                Gamma |- e1 ::: (TFun T1 T2) ->
                Gamma |- e2 ::: T1 ->
                Gamma |- (tapp e1 e2) ::: T2
  | T_CaseP : forall Gamma e e1 l r T T1 T2,
                Gamma |- e ::: (TPair T1 T2) ->
                let Omega := (type_update Gamma l T1)
                in (type_update Omega r T2) |- e1 ::: T ->
                Gamma |- (tcasep e l r e1) ::: T
where "Gamma '|-' t ':::' T" := (has_type Gamma t T).
\end{coqcode}
\end{frame}
\begin{frame}[fragile]{CuMin -- Funktionsspezialisierung}
\begin{coqcode}
T_Fun: forall Gamma id tys T,
         let result := lookup_func Prog id in 
         let fdecl  := fromOption default_fd result in
         specialize_func fdecl tys = Some T ->
         Forall (is_data_type Gamma)
                (fd_to_star_tys fdecl tys) ->
         Gamma |- (tfun id tys) ::: T
\end{coqcode}
\end{frame}
\begin{frame}{FlatCurry im Vergleich zu CuMin}
Syntax:
\begin{itemize}
	\item Weniger Ausdrücke und Typen, dafür allgemeinere Form
	\item Applikation von Funktionen auf mehr als ein Argument gleichzeitig
	\item Let Ausdrücke mit beliebig vielen Bindungen
\end{itemize}
$\rightarrow$ Komplexere Typisierungsregeln
\end{frame}
\begin{frame}{Zusammenfassung}
\end{frame}
\end{document}


