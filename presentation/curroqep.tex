\documentclass{beamer}
\usepackage{ulem}
\usepackage{proof}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{subcaption}
\usepackage{graphicx}
\usemintedstyle[haskell]{trac}
\newminted{haskell}{fontsize=\small}
\newminted{coq}{fontsize=\small}
\setmintedinline{style = bw}
\newcommand{\coqinline}[1]{\mintinline{coq}{#1}}

\mode<presentation>
{
  %\usetheme{Antibes}
  %\usecolortheme{lily}
  \usetheme{metropolis}
}


\usepackage[german]{babel}
% or whatever

\usepackage[utf8]{inputenc}
% or whatever

%\usepackage{times}
\usepackage[T1]{fontenc}
\setbeamersize{text margin left=1.5em,text margin right=1.5em}

\title{Formalisierung von Inferenzsystemen in Coq am Beispiel von Typsystemen für Curry}

%\subtitle{Bachelor's Thesis} % (optional)

\author{Niels Bunkenburg}

\institute{ 
	Arbeitsgruppe für Programmiersprachen und Übersetzerkonstruktion \par
	Institut für Informatik \par
	Christian-Albrechts-Universität zu Kiel}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[Short Occasion] % (optional)
{29.09.2016}

\subject{Formalisierung von Inferenzsystemen in Coq am Beispiel von Typsystemen für Curry}

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Motivation}
\hfill
\begin{minipage}[t]{.45 \linewidth}
	\centering
	\includegraphics[scale=.5]{images/curry_2.png}\\
	Curry
\end{minipage}
\hfill
\begin{minipage}[t]{.4 \linewidth}
	\centering
	\includegraphics[scale=.8]{images/coq_logo.png}\\
	Coq
\end{minipage}
\hfill
\par
\vfill
\hfill
\begin{minipage}[t]{.45 \linewidth}
	\centering
	\includegraphics[scale=1.2]{images/cumin_resized.jpg}\\
	CuMin
\end{minipage}
\hfill
\begin{minipage}[t]{.4 \linewidth}
	\centering
	\includegraphics[scale=.4]{images/flatcurry_resized.jpg}\\
	FlatCurry
\end{minipage}
\hfill
\end{frame}

\section{Introduction}
\subsection{Programming Languages}
\begin{frame}[fragile]{Curry}
\begin{itemize}
\item Syntax ähnlich zu Haskell
\item Nichtdeterminismus
\begin{haskellcode}
(?)   :: a -> a -> a
x ? _ = x
_ ? y = y
\end{haskellcode}
\item Freie Variablen
\begin{coqcode}
> 1 + 1 == x where x free
{x = (-_x2)} False
{x = 0} False
{x = 1} False
{x = 2} True
{x = (2 * _x3 + 1)} False
{x = (4 * _x4)} False
{x = (4 * _x4 + 2)} False		
\end{coqcode}
\end{itemize}
\end{frame}
\begin{frame}[fragile]{Coq - Aussagen}
\begin{itemize}
\item Gleichungen
\begin{coqcode}
1 + 1 = 2.
forall (X : Type) (l : list X), l ++ [] = l.
\end{coqcode}
\vfill
\item Induktiv definierte Aussagen
\begin{coqcode}
Inductive inInd : nat -> list nat -> Prop :=
 | head: forall n l, inInd n (n :: l)
 | tail: forall n l e, inInd n l -> inInd n (e :: l).
\end{coqcode}
\end{itemize}
\end{frame}
\subsection{Theory}
\begin{frame}{Was ist Typisierung?}
\begin{itemize}
	\item \textbf{Typ}: Menge von Werten, die Eigenschaften und Bedeutung der Elemente bestimmt, beispielsweise \texttt{Int, Maybe} oder \texttt{[]}.
	\item \textbf{Ausdruck}: Kombination von Literalen, Variablen, Operatoren und Funktionen, z.B. \texttt{1 + 1} or \texttt{map double}.
	\item \textbf{Kontext}: Enthält Informationen über Variablen und das Programm.
	\item \textbf{Typisierung}: In einem Kontext $\Gamma$ wird einem Ausdruck $e$ ein Typ $\tau$ zugewiesen, notiert als $\Gamma \vdash e :: \tau$.
\end{itemize}
Beispiele:
\begin{itemize}
	\item $\Gamma \vdash 2 :: \texttt{Int}$
	\item $\Gamma \vdash \texttt{let x = 2 in x + 2} :: \texttt{Int}$
\end{itemize}
%todo beispiel
\end{frame}
\begin{frame}[fragile]{Inferenzregeln}
\infer[\text{wo $p_i$ Prämissen und $c$ Konklusion der Regel.}]{c}{p_1 \dots p_n}
\begin{itemize}
	\item Notation für Implikation $p_1 \rightarrow \dots \rightarrow p_n \rightarrow c$
	\item Typing: \textbf{If} $p_1\dots p_n$ \textbf{then} $\Gamma e \vdash \tau$
\end{itemize}
\begin{center}
	\begin{minipage}{.45 \linewidth}
		\infer[\text{\texttt{In\_H}}]{\coqinline{In n (n :: l)}}{\phantom{premise}}
	\end{minipage}
	\hspace{.1 \linewidth}
	\begin{minipage}{.45 \linewidth}
		\infer[\text{\texttt{In\_T}}]{\coqinline{In n (e :: l)}}{\coqinline{In n l}}
	\end{minipage}
\end{center}
\end{frame}
\section{CuMin}
\subsection{Modeling}
\begin{frame}{Syntax -- Backus-Naur Form}
\begin{align*}
P &::= D;P \:|\:D \\
D &::= f :: \kappa \tau; f \overline{x_{n}} = e\\
\kappa &::= \forall^{\epsilon} \alpha.\kappa \:|\: \forall^{*}\alpha.\kappa \:|\: \epsilon \\
\tau &::= \alpha \:|\: \text{Bool} \:|\: \text{Nat} \:|\: [\tau] \:|\: (\tau,\tau ') \:|\: \tau \rightarrow \tau ' \\
e &::= x \:|\: f_{\overline{\tau_{m}}} \:|\: e_{1}\: e_{2} \:|\: \text{let}\: x = e_{1} \:\text{in}\: e_{2} \:|\: n \:|\: e_{1} + e_{2} \:|\: e_{1} \circeq e_{2}\\
&\:|\: (e_{1},e_{2}) \:|\: \text{case}\: e \:\text{of}\: \langle (x,y) \rightarrow e_{1}\rangle\\
&\:|\: \text{True} \:|\: \text{False} \:|\: \text{case}\: e \:\text{of}\: \langle \text{True} \rightarrow e_{1};\:\text{False} \rightarrow e_{2}\rangle\\
&\:|\: \text{Nil}_{\tau} \:|\: \text{Cons}(e_{1}, e_{2}) \:|\: \text{case}\: e \:\text{of}\: \langle \text{Nil} \rightarrow e_{1};\:\text{Cons}(x,y) \rightarrow e_{2}\rangle\\
&\:|\: \text{failure}_{\tau} \:|\: \text{anything}_{\tau}
\end{align*}
\end{frame}
\begin{frame}
\begin{minipage}{.45 \linewidth}
	\begin{align*}
	&\text{fst}::\forall^{*}\alpha.\forall^{*}\beta.(\alpha, \beta) \rightarrow\alpha\\
	&\text{fst}\: p = \text{case}\: p\: \text{of}\: \langle(u,v) \rightarrow u\rangle
	\end{align*}
\end{minipage}
\begin{minipage}{.45 \linewidth}
	\begin{align*}
	&\text{one} :: \text{Nat}\\
	&\text{one} = \text{fst}_{Nat, Bool} ~ (1, \text{True})
	\end{align*}
\end{minipage}
\end{frame}
\begin{frame}[fragile]{Syntax -- Coq}
\begin{coqcode}	
Inductive ty : Type :=
  | TVar  : id -> ty
  | TBool : ty
  | TNat  : ty
  | TList : ty -> ty
  | TPair : ty -> ty -> ty
  | TFun  : ty -> ty -> ty.

Definition program := list func_decl.
Inductive func_decl : Type :=
  | FDecl : id -> list quantifier ->
	ty -> list id -> tm -> func_decl.
\end{coqcode}
\end{frame}
\begin{frame}{Context}
\end{frame}
\subsection{Typing}
\begin{frame}{Typing rules}
\end{frame}
\begin{frame}{Examples}
\end{frame}
\section{FlatCurry}
\subsection{Differences to CuMin}
\begin{frame}{Syntax}
\end{frame}
\subsection{Typing}
\section{Conclusion}
\begin{frame}{Summary}
\end{frame}
\begin{frame}{Future Work}
\end{frame}

\end{document}


