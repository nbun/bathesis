% LaTeX-Muster Seminararbeit
\documentclass[fleqn]{scrreprt}

\usepackage[T1]{fontenc}        % T1-Fonts
\usepackage[utf8]{inputenc}     % Enkodierung
\usepackage[english]{babel}     % neue deutsche Rechtschreibung
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{hyperref}

% Kapitelüberschrift in der Kopfzeile
\usepackage[automark]{scrpage2} % Schickerer Satzspiegel mit KOMA-Script
\pagestyle{scrheadings}

% Minted
\usepackage{minted}

% Für schönere Tabellen (optional)
% \usepackage{booktabs}           % Netteres Tabellenlayout
% \usepackage{multicol}           % Mehrspaltige Bereiche
% \usepackage{tabularx}           % Tabellen mit fester Breite

% Für Listings
% \usepackage{listings}

% Eine kleine Hilfe für offene Lücken
\newcommand{\todo}[1]{\marginpar{\textbf{TODO:} #1}}
\newcommand{\coqinline}[1]{\mintinline{coq}{#1}}

\begin{document}

\pagenumbering{roman} % römische Seitenzahlen

% Titelseite - ganz einfach
\titlehead{\large Christian-Albrechts-Universität zu Kiel}
\subject{Bachelor Thesis\todo{Weitere Formalitäten...}}
\title{Title: TBD}
\date{SS~2016}
\author{Niels Bunkenburg}
\maketitle

% oder auch manuell

% Verzeichnisse
\renewcommand{\contentsname}{Contents}
\tableofcontents   % Inhaltsverzeichnis
% \listoffigures     % Abbildungsverzeichnis
% \listoftables      % Tabellenverzeichnis
% \lstlistoflistings % Abbildungsverzeichnis

\newpage               % Expliziter Umbruch für Seitenzahlen
\pagenumbering{arabic} % arabische Seitenzahlen

% Inhalt

% Entweder ausgegliedert in Dateien:
%   \include{chapter/introduction}
%   \include{chapter/fundamentals}
% oder direkt:


\chapter{Preliminaries}
\section{Coq}
The formalization of Curry programs requires a language that allows us to express the code itself and the propositions we intend to prove. Coq\footnote{https://coq.inria.fr/} is an interactive proof management system that meets these requirements, hence it will be the main tool used in the following chapters.
\todo{Kommasetzung?}
\subsection{Data types and functions}
Coq's predefined definitions, contrary to e.g. Haskell's Prelude, are very limited. However, being a functional language, there is a powerful mechanism for defining new data types. A definition of polymorphic lists could look like this:
\begin{minted}{coq}
Inductive list (X:Type) : Type :=
| nil  : list X
| cons : X -> list X -> list X.
\end{minted}
We defined a type named \coqinline{list} with two constructors: the constant \coqinline{nil}, which represents an empty list, and a binary constructor \coqinline{cons} that takes an element and a list of the same type as arguments. In fact, \coqinline{nil} and \coqinline{cons} have one additional argument, a type \coqinline{X}. This is required, because we want polymorphic lists -- but we do not want to explicitly state the type. Fortunately, Coq allows us to declare type arguments as implicit by enclosing them in curly brackets:
\begin{minted}{coq}
Check (cons nat 8 (nil nat)). (*cons nat 8 (nil nat) : list nat*)
Arguments nil {X}.
Arguments cons {X} _ _.
\end{minted}
Coq's type inference system infers the type of a list automatically now if possible. In some cases this does not work, because there is not enough information about the implicit types present. 
\begin{minted}{coq}
Fail Definition double_cons x y z := (cons x (cons y z)).
Definition double_cons {A} x y z := (@cons A x (@cons A y z)).
\end{minted}
The first definition does not work, as indicated by \coqinline{Fail}\footnote{\coqinline{Fail} checks if an expression does indeed cause an error and allows further processing of the file.}, because Coq cannot infer the implicit type variable of \coqinline{double_cons}, since \coqinline{cons} does not have an explicit type either. By prefixing at least one \coqinline{cons} with \coqinline{@}, we can tell Coq to accept explicit expressions for all implicit arguments. This allows us to pass the type of \coqinline{cons} on to \coqinline{double_cons}, again as an implicit argument.
\begin{minted}{coq}
Check double_cons 2 4 []. (* : list nat *)
Fail Check (cons 2 (cons nil nil)). 
(* Error: The term "cons nil nil" has type "list (list ?X0)"
while it is expected to have type "list nat". *)
\end{minted}
Based on this we can write a function that determines if a list is empty:
\begin{minted}{coq}
Definition isEmpty {X : Type} (l : list X) : bool := 
match l with
| nil      => true
| cons _ _ => false
end.
\end{minted}
Function definitions begin with the keyword \coqinline{Definition}. \coqinline{isEmpty} takes an (implicit) type and a list and returns a boolean value.
To distinguish empty from non-empty lists, pattern matching can be used on $n$ arguments by writing \coqinline{match} $x_{0},...,x_{n-1}$ \coqinline{with} | $p_{0} \rightarrow e_{0}$ | ... | $p_{m-1} \rightarrow e_{m-1}$ for $m$ pattern $p$, consisting of a sub-pattern for every $x_{i}$ and expressions $e_{i}$.

The definition of recursive functions requires that the function is called with a smaller structure than before in each iteration, which ensures that the function eventually terminates. A recursive function is indicated by using \coqinline{Fixpoint} instead of \coqinline{Definition}.
\begin{minted}{coq}
Fixpoint app {X : Type} (l1 l2 : list X) : (list X) :=
match l1 with
| nil => l2
| cons h t => cons h (app t l2)
end.
\end{minted}
In this case $l_{1}$ gets shorter with every iteration, thus the function terminates after a finite amount of recursions. 

Coq allows us to define notations for functions and constructors by using the keyword \coqinline{Notation}, followed by the desired syntax and the expression. 
\begin{minted}{coq}
Notation "x :: y" := (cons x y) (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y []) ..).
Notation "x ++ y" := (app x y) (at level 60, right associativity).
\end{minted}

\subsection{Propositions and proofs}
Every claim that we state or prove has the type \coqinline{Prop}. Propositions can be any statement, regardless of its truth. A few examples:
\begin{minted}{coq}
Check 1 + 1 = 2. (* : Prop *)
Check forall (X : Type) (l : list X), l ++ [] = l. (* : Prop *)
Check forall (n : nat), n > 0 -> n * n > 0. (* : Prop *)
Check (fun n => n <> 2). (* : nat -> Prop*)
\end{minted}
The first proposition is a simple equation, while the second one contains an universal quantifier. This allows us to state propositions about every type of list, or, as shown in the third example, about every natural number greater than zero. Combined with implications we can premise specific properties that limit the set of elements the proposition applies to. The last example contains an anonymous function, which is used by stating the functions' arguments and an expression.
\par
Now how do we prove these propositions? Proving an equation requires to show that both sides are equal, usually by simplifying one side until it looks exactly like the other. Coq allows us to do this by using tactics, which can perform a multitude of different operations.
\begin{minted}{coq}
Example e1 : 1+1=2.
Proof. simpl. reflexivity. Qed. 
\end{minted} 
\todo{Highlighting für Proof und Qed}
After naming the proposition as an example, theorem or lemma it appears in the interactive subgoal list that Coq provides. The \coqinline{simpl} tactic performs basic simplification like adding two numbers in this case. The updated subgoal is now \coqinline{2=2}, which is obviously true. By using the \coqinline{reflexivity} tactic we tell Coq to check both sides for equality, which succeeds and clears the subgoal list, followed by \coqinline{Qed} to complete the proof.
\begin{minted}{coq}
Example e2 : forall (X : Type) (l : list X), [] ++ l = l.
Proof. intros X l. reflexivity. Qed.
\end{minted}
Universal quantifiers allow us to introduce variables, the corresponding tactic is called \coqinline{intros}. The new context contains a type \coqinline{X} and a list \coqinline{l}, with the remaining subgoal \coqinline{[ ] ++ l = l}. Because we defined \coqinline{app} to return the second argument if the first one is an empty list, \coqinline{reflexivity} directly proves our goal. \coqinline{reflexivity} is not useful for obvious equations only, it also simplifies and unfolds definitions until the flat terms match each other if possible.
\par
To prove that the proposition \coqinline{l ++ [] = l} holds, we need more advanced tactics, because we cannot just apply the definition. \coqinline{app} works by iterating through the first list, but we need to prove the proposition for every list, regardless of its length. One possibility to solve this problem is by using structural induction.
\begin{minted}{coq}
Example e3 : forall (X : Type) (l : list X), l ++ [] = l.
Proof. intros X. induction l as [|l ls IH].
reflexivity.
simpl. rewrite IH. reflexivity.
Qed.
\end{minted}
The proof begins by introducing type \coqinline{X}, followed by the \coqinline{induction} tactic applied to \coqinline{l}. Coq names newly introduced variables by itself, which can be done manually by adding \coqinline{as [c1|...|cn]} to the tactic. Each $c_{i}$ represents a sequence of variable names, which will be used when introducing variables in the corresponding case. Cases are ordered as listed in the \coqinline{Definition}.
\par
Now we need to prove two cases: the empty list and a cons construct. The first case does not require any new variable names, therefore the first section in the squared brackets is empty. It is easily solved by applying \coqinline{reflexivity}, because of the definition of \coqinline{app}.
The second case requires variables for the list's head and tail, which we call \coqinline{l} and \coqinline{ls} respectively. The variable name \coqinline{IH} identifies the induction hypothesis \coqinline{ls ++ [ ] = ls}, which Coq generates automatically. The goal changes as following:
\begin{minted}{coq}
(l :: ls) ++ [ ] = l :: ls
 l :: ls  ++ [ ] = l :: ls (* simpl *)
 l :: ls         = l :: ls (* rewrite with IH *)
\end{minted}
The tactic \coqinline{rewrite} changes the current goal by replacing every occurrence of the left side of the provided equation with the right side. Both sides are equal now, hence \coqinline{reflexivity} proves the last case.
\par 
Example \coqinline{e4} is different from the other examples, in the sense that one cannot prove a function by itself and that only supplying an argument returns a verifiable inequality. 
\begin{minted}{coq}
Example e4 : (fun n => n <> 2) 1.
Proof.
  simpl.       (* 1 <> 2 *)
  unfold not.  (* 1 = 2 -> False *)
  intros H.    (* H : 1 = 2, False *)
  inversion H. (* No more subgoals. *)
Qed.
\end{minted}
This proof is not as straight forward as the other ones, mainly because of the inequality, which is a notation\footnote{It is often useful to be able to look up notations, \coqinline{Locate "<>"} returns the term associated with \coqinline{<>}.} for \coqinline{not (x = y)}. Because \coqinline{not} is the outermost term, we need to eliminate it first by applying \coqinline{unfold}. This replaces \coqinline{not} with its definition \coqinline{fun A : Prop => A -> False}, where \coqinline{False} is the unprovable proposition. Why does this work?
Assuming that a proposition \coqinline{P} is true, \coqinline{not P} means that \coqinline{P} implies \coqinline{False}, which is false, because something true cannot imply something false. On the other hand, if \coqinline{P} is false, then \coqinline{False -> False} is true because anything follows from falsehood, as stated by the principle of explosion. \todo{verweis?}
\par
The current goal \coqinline{4 = 8 -> False} is further simplified by introducing \coqinline{4 = 8} as an hypothesis \coqinline{H}, leaving \coqinline{False} as the remaining goal. Intuitively we know that \coqinline{H} is false, but Coq needs a justification for this claim.
Conveniently the tactic \coqinline{inversion} solves this problem easily by applying two core principles of inductively defined data types:
\begin{itemize}
	\item Injectivity: \coqinline{C n = C m} implies that n and m are equal for a constructor \coqinline{C}.
	\item Disjoint constructors: Values created by different constructors cannot be equal.
\end{itemize}
By applying \coqinline{inversion} to the hypothesis \coqinline{2 = 1} we tell Coq to add all inferable equations as additional hypotheses. In this case we start with \coqinline{2 = 1} or the Peano number representation \coqinline{S(S(O)) = S(0)}. Injectivity implies that if the previous equation was true, \coqinline{S(O) = O} must also be true. This is obviously false, since it would allow two different representations of nil. Hence, the application of \coqinline{inversion} to \coqinline{2 = 1} infers the current goal \coqinline{False}, which concludes the proof.

Besides directly supplying arguments to functions that return propositions, there are other interesting applications for them, that we will discuss in the next section.

\subsection{Higher-order constructs}
Functions can be passed as arguments to other functions or returned as a result, they are first-class citizens in Coq. This allows us create higher-order functions, such as \coqinline{map} or \coqinline{fold}.
\todo{minted bug?}
\begin{minted}{coq}
Fixpoint map {X Y : Type} (f : X -> Y) (l : list X) : (list Y) :=
  match l with
  | []     => []
  | h :: t => (f h) :: (map f t)
  end.
\end{minted}
Function types are represented by combining two or more type variables with an arrow. Coq does not only allow higher-order functions, but also higher-order propositions. A predefined example is \coqinline{Forall}, which features a \coqinline{A -> Prop} construct from the last section.
\begin{minted}{coq}
Forall : forall A : Type, (A -> Prop) -> list A -> Prop
\end{minted}
\coqinline{Forall} takes a \textit{property} of \coqinline{A}, which returns a \coqinline{Prop} for any given \coqinline{A}, plus a list of \coqinline{A} and returns a proposition. It works by applying the property to every element of the given list and can be proven by showing that all elements satisfy the property.
\begin{minted}{coq}
Example e5 : Forall (fun n => n <> 8) [2;4].
Proof.
apply Forall_cons. intros H. inversion H.
(* Forall (fun n : nat => n <> 8) [4] *)
apply Forall_cons. intros H. inversion H.
(* Forall (fun n : nat => n <> 8) [ ] *)
apply Forall_nil.
Qed.
\end{minted}
\coqinline{Forall} is an inductively defined proposition, which requires rules to be applied in order to prove a certain goal. This will be further explained in the next section, for now it sufficient to know that \coqinline{Forall} can be proven by applying the rules \coqinline{Forall_cons} and \coqinline{Forall_nil}, depending on the remaining list. Because we begin with a non-empty list, we have to apply \coqinline{Forall_cons}. The goal changes to \coqinline{2 <> 8}, the head of the list applied to the property. We have already proven this type of inequality before, \coqinline{inversion} is actually able to do most of the work we did manually by itself. Next the same procedure needs to be done for the list's tail \coqinline{[4]}, which works exactly the same as before. To conclude the proof, we need to show that the property is satisfied by the empty list. \coqinline{Forall_nil} covers this case, which is trivially fulfilled.
\subsection{Inductively defined propositions}
Properties of a data type can be written in multiple ways, two of which we already discussed: Boolean equations of the form \coqinline{b x = true} and functions that return propositions. For example the function \coqinline{InB} returns \coqinline{true} if a \coqinline{nat} is contained in a list, the boolean function could look like this:
\begin{minted}{coq}
Fixpoint InB (x : nat) (l : list nat) : bool :=
match l with
| [] => false
| x' :: l' => if (beq_nat x x') then true else InB x l'
end.
Example e5 : InB 42 [1;2;42] = true.
Proof. reflexivity. Qed.
\end{minted}
Because \coqinline{InB} returns a boolean value, we have to check for equality with \coqinline{true} in order to get a provable proposition. The proof is fairly simple, \coqinline{reflexivity} evaluates the expression and checks the equation, nothing more needs to be done.
\par 
Properties are another approach that works equally well. This definition connects multiple equations by disjunction, noted as \coqinline{\/}. The resulting proposition needs to contain a least one true equation to become true itself.
\begin{minted}{coq}
Fixpoint In (x : nat) (l : list nat) : Prop :=
match l with
| [] => False
| x' :: l' => x' = x \/ In x l'
end.
Example e6 : In 42 [1;2;42].
Proof. 
  simpl. (* 1 = 42 \/ 2 = 42 \/ 42 = 42 \/ False *)
  right.           (* 2 = 42 \/ 42 = 42 \/ False *)
  right.                     (* 42 = 42 \/ False *)
  left.                      (* 42 = 42 *)
  reflexivity.
Qed.
\end{minted}
Proving the same example as before, we need new tactics to work with logical connectives. By simplifying the original statement we get a disjunction of equations for every element in the list. If we want to show that a disjunction is true, we need to choose a side we believe to be true and prove it. \coqinline{left} and \coqinline{right} keep only the respective side as the current goal, discarding the other one. A similar tactic exists for the logical conjunction \coqinline{/\ }, with the difference that \coqinline{split} keeps both sides as subgoals, since a conjunction is only true if both sides are true.
\par
The last option to describe this property is by using inductively defined propositions. As already mentioned before, inductively defined propositions consist of rules that describe how an argument can satisfy the proposition. A useful notation for representing these rules are \textit{inference rules}. They consist of an optional list of premises that needs to be fulfilled in order for the conclusion below the line to hold.
\par
We can describe \coqinline{In} with two rules:
\begin{figure}[H]
\begin{center}
		\begin{minipage}{.45 \linewidth}
		\infer[1]{\coqinline{In n (n :: l)}}{\phantom{premise}}
	\end{minipage}
    \hspace{.1 \linewidth}
	\begin{minipage}{.45 \linewidth}
		\infer[2]{\coqinline{In n (e :: l)}}{\coqinline{In n l}}
	\end{minipage}
\end{center}
\vspace*{-1em}
\end{figure}
Rule one states that the list's head is an element of the list. Additionally, if an element is contained in a list, it is also an element of the the same list, prefixed by another element, as described in the second rule. This definition can be transferred to Coq:
\begin{minted}{coq}
Inductive InInd : nat -> list nat -> Prop :=
| Head : forall n l, InInd n (n :: l)
| Tail : forall n l, InInd n (tl l) -> InInd n l.
\end{minted}
\begin{minted}{coq}
Example e7 : InInd 42 [2;42].
Proof. 
  apply Tail.  (* InInd 42 (tl [2; 42]) *)
  simpl.       (* InInd 42 [42] *)
  apply Head.
Qed.           
\end{minted}
The interesting part about this proof is the deductive approach. Previously we started with a proposition and constructed evidence of its truth. In this case we use \coqinline{InInd}'s rules "backwards": Because we want to show that \coqinline{42} is an element of \coqinline{[2;42]]}, we need to argue that it is contained within the list's tail. Since it is the head of \coqinline{[42]}, we can then apply \coqinline{Head} and conclude that the previous statement must also be true, because we required \coqinline{42} to be contained in the list's tail, which is true.
\par
Inductively defined propositions will play an important role in the following chapters, hence some more examples:
\begin{minted}{coq}
Inductive Forall (A : Type) (P : A -> Prop) : list A -> Prop :=
| Forall_nil : Forall P [ ]
| Forall_cons : forall (x : A) (l : list A), P x -> Forall P l -> Forall P (x :: l)
\end{minted}
We already used \coqinline{Forall} in the previous section without knowing the exact definition, the rules are fairly intuitive. According to \coqinline{Forall_nil}, a proposition is always true for the empty list. If the list is non-empty, the first element and the list's tail have to satisfy the proposition, as stated in \coqinline{Forall_cons}, in order for the whole list to satisfy the property. This pattern can be expanded to more complex inductive propositions, \coqinline{Forall2} takes a binary property plus two lists and checks if $P ~ a_{i} ~ b_{i}$ holds for every \coqinline{i < length l}.
\begin{minted}{coq}
Forall2 : forall A B : Type, (A -> B -> Prop) -> list A -> list B -> Prop
\end{minted}
\section{FlatCurry}

\chapter{Theory}
In functional languages a data type is a classification of applicable operators and properties of its members. There are primitive data types that store a single date and more complex types that may contain multiple constructors and type variables. Typing describes the process of assigning an expression to a corresponding type in order to avoid programming errors, for example calling an arithmetic function with a character.
\par
Typing an expression requires a context which contains data type definitions, function/constructor/operator declarations and a map that assigns types to variables.  Without a context, expressions do not have any useful meaning -- \coqinline{42} could be typed as a number, the character 'B', a string or the answer to everything. The majority of information in a context can be extracted from the source code of a program and is continually updated while typing expressions.
\chapter{CuMin}
CuMin is a simplified sublanguage of Curry, which restricts the syntax to allow more concrete typing rules and data types. Although it requires some transformations to substitute missing constructs, CuMin can express the majority of Curry programs.
\autoref{cumin:syntax} shows the syntax of CuMin in Backus–Naur Form:
\begin{figure}[H]
	\begin{align*}
	P &::= D;P \:|\:D \\
	D &::= f :: \kappa \tau; f \overline{x_{n}} = e\\
	\kappa &::= \forall^{\epsilon} \alpha.\kappa \:|\: \forall^{*}\alpha.\kappa \:|\: \epsilon \\
	\tau &::= \alpha \:|\: \text{Bool} \:|\: \text{Nat} \:|\: [\tau] \:|\: (\tau,\tau ') \:|\: \tau \rightarrow \tau ' \\
	e &::= x \:|\: f_{\overline{\tau_{m}}} \:|\: e_{1}\: e_{2} \:|\: \text{let}\: x = e_{1} \:\text{in}\: e_{2} \:|\: n \:|\: e_{1} + e_{2} \:|\: e_{1} \circeq e_{2}\\
	&\:|\: (e_{1},e_{2}) \:|\: \text{case}\: e \:\text{of}\: \langle (x,y) \rightarrow e_{1}\rangle\\
	&\:|\: \text{True} \:|\: \text{False} \:|\: \text{case}\: e \:\text{of}\: \langle \text{True} \rightarrow e_{1};\:\text{False} \rightarrow e_{2}\rangle\\
	&\:|\: \text{Nil}_{\tau} \:|\: \text{Cons}(e_{1}, e_{2}) \:|\: \text{case}\: e \:\text{of}\: \langle \text{Nil} \rightarrow e_{1};\:\text{Cons}(x,y) \rightarrow e_{2}\rangle\\
	&\:|\: \text{failure}_{\tau} \:|\: \text{anything}_{\tau}
	\end{align*}
	\caption{Syntax of CuMin}
	\label{cumin:syntax}
\end{figure}
\todo{Komisches 4-fach =}
A program $P$ is a list of function declarations $D$, which contain a function name $f$, a list of quantifiers $\kappa$, a type $\tau$ and a function definition. Quantifiers have a tag $t \in \{\epsilon, *\}$ that determines the valid types of the variable $\alpha$. Star-tagged type variables can only be specialized to non-functional types, while $\epsilon$ allows every specialization. The notation $\overline{x_{n}}$ in function definitions represents $n$ variables $x_{1},...,x_{n}$ that occur after the function name and are followed by an expression $e$. A function's type $\tau$ can consist of type variables, primitive Bool or Nat types, lists, pairs and functions. An example for a CuMin function is \texttt{first}, which returns the first element of a pair:
\begin{figure}[H]
\begin{minipage}{.5 \linewidth}
\begin{align*}
&\text{first}::\forall^{\epsilon}\alpha.\forall^{\epsilon}\beta.(\alpha, \beta) \rightarrow\alpha\\
&\text{first}\: p = \text{case}\: p\: \text{of}\: \langle(u,v) \rightarrow u\rangle
\end{align*}
\end{minipage}
\begin{minipage}{.5 \linewidth}
\begin{align*}
&\text{one} :: \epsilon \: \text{Nat}\\
&\text{one} = \text{first}_{Nat, Bool} (1, \text{True})
\end{align*}
\end{minipage}
\end{figure}
It is important to notice that polymorphic functions need to be explicitly specialized before they are applied to another expression, as shown in \texttt{one}, because there is no type inference.
\par
Besides function application, there are literal boolean values and natural numbers, variables, arithmetic expressions, let bindings and case constructs and constructors for pairs and lists. The two remaining expressions arise from Curry's logical parts: anything$_{\tau}$ represents every possible value of type $\tau$, similar to free variables. failure$_{\tau}$ represents a failed computation, for example $\text{fail} = \text{anything}_{Nat} \circeq \text{True}$. Since anything$_{Nat}$ can be evaluated to natural numbers only, the equation always fails because Nat and Bool are not comparable.
\begin{figure}[H]
\begin{minipage}[t]{.5 \linewidth}
\begin{minted}{coq}
Inductive tm : Type :=
| tvar   : id -> tm
| tapp   : tm -> tm -> tm
| tfun   : id -> list ty -> tm
| tlet   : tm -> tm -> tm -> tm
| ttrue  : tm
| tfalse : tm
| tfail  : ty -> tm
| tany   : ty -> tm
| tzero  : tm
| tsucc  : tm -> tm
| tadd   : tm -> tm -> tm
| teqn   : tm -> tm -> tm
| tpair  : tm -> tm -> tm
| tnil   : tm
| tcons  : tm -> tm -> tm
| tcasep : tm -> tm -> tm
| tcaseb : tm -> tm -> tm -> tm
| tcasel : tm -> tm -> tm -> tm.
\end{minted}
\end{minipage}
\begin{minipage}[t]{.5 \linewidth}
\begin{minted}{coq}
Inductive tag : Type :=
| tag_star  : tag
| tag_empty : tag.
  
Inductive ty : Type :=
| TVar  : id -> ty
| TBool : ty
| TNat  : ty
| TList : ty -> ty
| TPair : ty -> ty -> ty
| TFun  : ty -> ty -> ty.
\end{minted}
\end{minipage}
\end{figure}
\chapter{Curry}
\section{FlatCurry}
\section{Typing}
\subsection{Differences to CuMin}
\subsection{Conversion of FlatCurry to Coq}
\chapter{Conclusion}

% Anhang
\appendix
%\chapter{Syntax von Haskell}

%\todo{Fehlt noch!}

% Literatur
\bibliographystyle{alphadin}
\bibliography{seminar} % Datei: seminar.bib

\end{document}